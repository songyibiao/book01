# 移植U8g2单色图形库驱动OLED

> *本小节教你将U8g2单色图形库移植到STM32单片机上，用于驱动0.96 OLED 液晶屏显示模块。*

### U8g2是什么

U8g2 是目前 Arduino 平台上使用最广泛的单色屏驱动库，在 Github 上超过 1.3K Star，1800 Commit，现在移植到了 STM32 上，同样可以满足各种各样的需求。

### U8g2的优势

为什么要运用 U8g2 库？也就是说 U8g2 库能带给我们什么样的开发便利。主要考虑几个方面：

* U8g2 库显示控制器支持性好，基本上市面上的 OLED 都完美支持；

* U8g2 库 API 众多，特别支持了中文，支持了不同字体。

* u8g2 库移植简单，容易使用。

### 六线 SPI 0.96 OLED

小霸王Lite两轮自平衡小车上使用 0.96 寸 OLED 液晶屏显示模块，使用 SPI 通信接口。

引脚说明：

GND 电源地
VCC 2.2v-5.5v
SCL CLK时钟
SDA MOSI数据
RST 复位
D/C 数据/命令

### 像素点点阵

OLED 其实就是一个 M x N 的像素点阵，想显示什么就得把具体位置的像素点亮起来。对于每一个像素点，有可能是 1 点亮，也有可能是 0 点亮；

### 坐标系

![](/img/TB2O5.qpl0kpuFjSsppXXcGTXXa_!!361121710.jpg)

在坐标系中，左上角是原点，向右是X轴，向下是Y轴。

### 移植步骤

了解引脚接线。

![引脚接线](/img/2019-09-08_204716.png)

我们并没有使用 STM32 的硬件 SPI 接口，这里使用 GPIO 口 模拟 SPI 进行通信。

进入我们上一小节实验的 MiaowLabs-Demo 文件夹，找到 MiaowLabs-Demo.ioc 工程文件，双击，打开工程。

![配置相关引脚](/img/2019-09-08_211839.png)

配置完毕，点击生成代码按钮，重新生成代码。

> 相关链接：[U8g2](https://github.com/olikraus/u8g2/)

先从上面相关链接，打开 Github，下载 U8g2 的代码压缩包。你可以把压缩包保持到桌面。

![下载U8g2代码](/img/2019-09-07_205818.png)

对压缩包解压，可以看到 u8g2-master 文件夹里有好多文件和文件夹。

![解压](/img/2019-09-07_210840.png)

我们在移植过程总主要用的是 csrc 文件夹里面的文件，其他文件夹和文件可以等有空再去探究。

在 csrc 文件夹里，点击按类型排序，可以看到有两个 .h 头文件（u8g2.h 和 u8x8.h），其他的都是 .c 源文件。其中，u8x8_d_xxx.c 之类的文件是对应屏幕驱动的文件，我们在这里使用 `u8x8_d_ssd1306_128x64_noname.c`。 复制 csrc 文件夹里面的两个 .h 头文件到小车项目工程里的 Inc 文件夹，复制其他的所有文件到 Src 文件夹（注意，  u8x8_d_xxx.c 这类文件只保留 `u8x8_d_ssd1306_128x64_noname.c`）。

> 其中 u8x8_d_ssd1306_128x64_noname.c 是随 oled 屏的驱动芯片来选择的（这里 OLED 的驱动芯片是 ssd1306 ）

![复制头文件到Inc文件夹中](/img/2019-09-08_203358.png)

![复制源文件到Src文件夹中](/img/2019-09-08_203205.png)

使用 MDK-ARM 打开工程，把复制到 Src 文件夹中的源文件都加入到工程的 Application/User 文件夹中去。

![把相关文件全部加入到MDK-ARM工程中](/img/2019-09-08_203815.png)

在 main.c 中添加两个 .h 头文件：

![在main.c中添加h头文件](/img/2019-09-08_212648.png)

新建一个文件，保存到 Inc 文件夹，命名为 oled.h，敲入以下代码：

```c
#ifndef __OLED_H_
#define __OLED_H_

#include "u8g2.h"
#include "u8x8.h"

void OLED_Init(void);
uint8_t u8x8_stm32_gpio_and_delay(U8X8_UNUSED u8x8_t *u8x8,
    U8X8_UNUSED uint8_t msg, U8X8_UNUSED uint8_t arg_int,
    U8X8_UNUSED void *arg_ptr);

#endif
```

新建一个文件，保存到 Src 文件夹，命名为 oled.c。

然后在再加入以下代码，即创建一个回调函数（可根据相关的宏来知其意，比如U8X8_MSG_GPIO_SPI_DATA就是表示软件模拟spi的数据管脚，那个arg_int表示是将当前管脚置高还是复位，其中的OLED_Init()是OLED初始化函数）：

```c

#include "gpio.h"
#include "oled.h"


#define OLED_RST_Clr() HAL_GPIO_WritePin(GPIOB,OLED_RST_Pin,GPIO_PIN_RESET)
#define OLED_RST_Set() HAL_GPIO_WritePin(GPIOB,OLED_RST_Pin,GPIO_PIN_SET)

#define OLED_DC_Clr() HAL_GPIO_WritePin(GPIOC,OLED_DC_Pin,GPIO_PIN_RESET)
#define OLED_DC_Set() HAL_GPIO_WritePin(GPIOC,OLED_DC_Pin,GPIO_PIN_SET)

#define OLED_SCLK_Clr() HAL_GPIO_WritePin(GPIOB,OLED_SCL_Pin,GPIO_PIN_RESET)
#define OLED_SCLK_Set() HAL_GPIO_WritePin(GPIOB,OLED_SCL_Pin,GPIO_PIN_SET)

#define OLED_SDIN_Clr() HAL_GPIO_WritePin(GPIOB,OLED_SDA_Pin,GPIO_PIN_RESET)
#define OLED_SDIN_Set() HAL_GPIO_WritePin(GPIOB,OLED_SDA_Pin,GPIO_PIN_SET)

void OLED_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* GPIOB/GPIOC clock enable */
  __HAL_RCC_GPIOB_CLK_ENABLE();
  __HAL_RCC_GPIOC_CLK_ENABLE(); 

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(OLED_DC_GPIO_Port, OLED_DC_Pin, GPIO_PIN_RESET);
  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, LED_Pin|OLED_RST_Pin|OLED_SDA_Pin|OLED_SCL_Pin, GPIO_PIN_RESET);
  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = OLED_DC_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(OLED_DC_GPIO_Port, &GPIO_InitStruct);
  /*Configure GPIO pins : PBPin PBPin PBPin PBPin 
                           PBPin */
  GPIO_InitStruct.Pin = OLED_RST_Pin|OLED_SDA_Pin|OLED_SCL_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);    
    
}

uint8_t u8x8_stm32_gpio_and_delay(U8X8_UNUSED u8x8_t *u8x8,
    U8X8_UNUSED uint8_t msg, U8X8_UNUSED uint8_t arg_int,
    U8X8_UNUSED void *arg_ptr)
{
  switch (msg)
  {
        case U8X8_MSG_GPIO_AND_DELAY_INIT:
			OLED_Init();					
		break;
		case U8X8_MSG_GPIO_SPI_DATA:
			if(arg_int)OLED_SDIN_Set();
            else OLED_SDIN_Clr();
		break;
		case U8X8_MSG_GPIO_SPI_CLOCK:
			if(arg_int)OLED_SCLK_Set();
            else OLED_SCLK_Clr();
		break;		
		case U8X8_MSG_GPIO_CS:
			//CS默认接地
		case U8X8_MSG_GPIO_DC:
			if(arg_int)OLED_DC_Set();
            else OLED_DC_Clr();
		break;
		case U8X8_MSG_GPIO_RESET:
			if(arg_int)OLED_RST_Set();
            else OLED_RST_Clr();
		break;
        //Function which delays 100ns  
        case U8X8_MSG_DELAY_100NANO:  
            __NOP();  
        break;  
        case U8X8_MSG_DELAY_MILLI:
			HAL_Delay(arg_int);
		break;
        default:
            return 0;//A message was received which is not implemented, return 0 to indicate an error
  }
  return 1;
}
```

裁剪  u8g2_d_setup.c   u8g2_d_memory.c 文件中与 ssd1306 无关的代码，减小代码体积，ram用量。

u8g2_d_setup.c 只保留 u8g2_Setup_ssd1306_128x64_noname_f 函数，其他全部删掉。

![裁剪u8g2_d_setup.c](/img/2019-09-08_214618.png)

u8g2_d_memory.c 只保留 *u8g2_m_16_8_f 函数，其他全部删掉。

![裁剪u8g2_d_memory.c](/img/2019-09-08_214737.png)

在 main.h 头文件加入 oled.h 头文件。

![加入oled.h头文件](/img/2019-09-08_215903.png)

在主函数中初始化 u8g2，先创建 u8g2 的句柄，并创建一个临时变量 nTemp：

![创建 u8g2 句柄](/img/2019-09-08_221322.png)

修改 main() 函数，初始化 u8g2 显示库，增加显示代码。

```c
u8g2_Setup_ssd1306_128x64_noname_f(&u8g2,U8G2_R0,u8x8_byte_4wire_sw_spi,u8x8_stm32_gpio_and_delay);//初始化u8g2
  u8g2_InitDisplay(&u8g2);//初始zai化显示器
  u8g2_SetPowerSave(&u8g2,0);//唤醒显示器
```

![初始化u8g2](/img/2019-09-08_221511.png)

在主循环中添加以下代码：

```c
u8g2_ClearBuffer(&u8g2);//清空缓冲区的内容
       if(++nTemp>=32) nTemp=1;
      u8g2_DrawCircle(&u8g2,64,32,nTemp,U8G2_DRAW_ALL);//画圆
      u8g2_DrawCircle(&u8g2,32,32,nTemp,U8G2_DRAW_ALL);//画圆
	  u8g2_DrawCircle(&u8g2,96,32,nTemp,U8G2_DRAW_ALL);//画圆
      u8g2_SendBuffer(&u8g2);//绘制缓冲区的内容
```

![修改主循环代码](/img/2019-09-08_221840.png)

重新编译，下载，可以看到三个循环变化圆环不断地变化。

![OLED显示三个圆环](/img/IMG_9875.JPG)














